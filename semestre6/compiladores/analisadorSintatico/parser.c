#include <stdio.h>
#include <stdlib.h>
#include "parser.h"
#include "front.h"


static void error();

/**
 * This is the example Recursive-Descent Parser in pp. 181 - 185 in the 
 * textbook 
 *
 * Sebesta, R. W. (2012). Concepts of Programming Languages. 
 * Pearson, 10th edition.
 *
 *
 * */

/* expr
 * Parses strings in the language generated by the rule:
 * <expr> -> <term> {(+ | -) <term>}
 */
void program(){
	printf("Enter <program>\n");
	if( nextToken == MAIN_KEYW){
			lex();
			if( nextToken==LEFT_PAREN){
				lex();
				if(nextToken==RIGHT_PAREN){
					lex();
					if(nextToken==LEFT_BRACK){
						lex();
						stmts();
						if(nextToken ==RIGHT_BRACK)
							lex();
						else
							error();
					}
					else
						error();
					
				}
				else
					error();
			}
			else
				error();
	}
	else
		error();
	printf("Exit <program>\n");
}

void stmts(){
	printf("Enter <stmts>\n");
	stmt();
	
	if( nextToken == IF_KEYW || nextToken == FOR_KEYW || nextToken == IDENT){
		stmts();
	}
	printf("Exit <stmts>\n");
}

void stmt(){
	printf("Enter <stmt>\n");
	if( nextToken==IDENT){
		atr();
	}
	else if( nextToken == IF_KEYW){
			if_stmt();
	}
	else if( nextToken == FOR_KEYW){
			for_stmt();
	}
	else
		error();
	
	printf("Exit <stmt>\n");
}

void atr(){
	printf("Enter <atr>\n");
	 if (nextToken == IDENT){
	 		var();
	 		if(nextToken== EQ_OP){
	 			lex();
	 			expr();
	 			if(nextToken==PONTO_VIRGULA)
	 				lex();
	 		}
	 		else
	 			error();
	 }
	 else
	 	error();
	 printf("Exit <atr>\n");
}




void var(){
	printf("Enter <var>\n");
	if (nextToken==IDENT)
		lex();
	else
		error();
	printf("Exit <var>\n");
}



void expr() 
{
    printf("Enter <expr>\n");

    term();

   
    while (nextToken == ADD_OP || nextToken == SUB_OP || nextToken == EQ_OP || nextToken == LESS_OP || nextToken==REL_OPS) {
        lex();
        term();
    }

    printf("Exit <expr>\n");
} 


void term() 
{
    printf("Enter <term>\n");
   
    factor();
    
    while (nextToken == MULT_OP || nextToken == DIV_OP) {
            lex();
            factor();
    }
    printf("Exit <term>\n");
} /* End of function term */


void factor() 
{
    printf("Enter <factor>\n");
    
    if (nextToken == IDENT){
    	var();
    }
    else if(nextToken == INT_LIT){
    		lex();
	} 
    else {
        
        if (nextToken == LEFT_PAREN) {
            lex(); 
            expr();

            if (nextToken == RIGHT_PAREN) {
                lex(); 
            } else { 
                error();
            }
        }
        else { 
            error(); 
        }
    } 
    printf("Exit <factor>\n");
} 



void for_stmt(){
	printf("Enter <for_stmt>\n");
	if(nextToken==FOR_KEYW){
		lex();
		if(nextToken==LEFT_PAREN){
			lex();
			atr();
			expr();
			if(nextToken==PONTO_VIRGULA){
				lex();
				expr();
				if(nextToken==RIGHT_PAREN)
					lex();
				else
					error();
				if(nextToken==LEFT_BRACK){
					lex();
					stmts();
				
					if(nextToken==RIGHT_BRACK)
						lex();
					else
						error();
					
					
				}
				else
							error();
			}
			else
							error();
			
		}
		else
								error();
	}
	else
								error();


	printf("Exit <for_stmt>\n");
}

void if_stmt(){	
	printf("Enter <if_stmt>\n");
	if(nextToken==IF_KEYW){
			lex();
			if(nextToken== LEFT_PAREN){
				logic_expr();
				if(nextToken == RIGHT_PAREN)
					lex();
					if(nextToken == LEFT_BRACK ){
						lex();
						stmts();
						if(nextToken == RIGHT_BRACK)
							lex();
						else
							error();
					}
					else
						error();
			}
			else
				error();
	}
	else
		error();
	printf("Exit <if_stmt>\n");
	}




	

void logic_expr(){
	printf("Enter <logic_expr>\n");
	if(nextToken==IDENT){
			var();
	}
	else if ( nextToken == LEFT_PAREN){
		lex();
		logic_expr();
		Y();
		logic_expr();
		if( nextToken == RIGHT_PAREN)
			lex();
		else
			error();
	}
	else
		error();	
	printf("Exit <logic_expr>\n");

}
void Y(){
	printf("Enter <Y>\n");
	if(nextToken==REL_OPS || nextToken==EQ_OP || nextToken==LESS_OP)
		lex();
	else
		error();
	printf("Exit <Y>\n");
}

static void error() 
{
    printf("Error (more is desired, but not implemented).\n");
}
