#include <stdio.h>
#include <stdlib.h>

// Aluno: Igor Lima Rocha
// Referencia: https://github.com/gbfragoso/P-code-machine

#define CXMAX 200
#define STACKSIZE 500
#define LIMITE_MAX 20

const int amax = 2047, levmax = 3;

enum fct {LIT, OPR, LOD, STO, CAL, INT, JMP, JPC, END};
typedef struct {
    enum fct f;
    int l;
    int a;
}  Instruction;

Instruction code[CXMAX];
int s[STACKSIZE];
int p, b, t;

int base(int l){
    int b1;
    b1 = b;
    while(l > 0){
        b1 = s[b1];
        l = l-1;
    }
    return b1;
}

int main(){
  // Instructions:
  code[0].f = INT; code[0].l = 0; code[0].a = 5;
  code[1].f = LIT; code[1].l = 0; code[1].a = 1;     // Inicia contador
  code[2].f = STO; code[2].l = 0; code[2].a = 0;
  code[3].f = LIT; code[3].l = 0; code[3].a = LIMITE_MAX;   // Configura máximo (Mínimo possivel sem bugar é 31)
  code[4].f = STO; code[4].l = 0; code[4].a = 1;
  code[5].f = LOD; code[5].l = 0; code[5].a = 0;     // Inicio do loop (load aux)
  code[6].f = LOD; code[6].l = 0; code[6].a = 2;     // Load Soma
  code[7].f = OPR; code[7].l = 0; code[7].a = 2;     // Soma + Aux
  code[8].f = STO; code[8].l = 0; code[8].a = 2;     // Salva a soma
  code[9].f = LOD; code[9].l = 0; code[9].a = 0;     // Load aux
  code[10].f = LOD; code[10].l = 0; code[10].a = 1;  // Load Máximo
  code[11].f = OPR; code[11].l = 0; code[11].a = 10; // Menor que
  code[12].f = JPC; code[12].l = 0; code[12].a = 17; // Saida do loop
  code[13].f = LOD; code[13].l = 0; code[13].a = 0;  // Load aux
  code[14].f = OPR; code[14].l = 0; code[14].a = 2;  // Aux + 1
  code[15].f = STO; code[15].l = 0; code[15].a = 0;
  code[16].f = JMP; code[16].l = 0; code[16].a = 5;  // Fim do loop
  code[17].f = END; code[17].l = 0; code[17].a = 0;

  // PCode Machine:
  Instruction i;
  {
      printf(" start pl/0 ");
      t = 0;
      b = 1;
      p = 0;
      s[1] = 0;
      s[2] = 0;
      s[3] = 0;
      printf("\n| t |  b |  p |");
      do {
          i =  code[p];
          printf("\n|%2d | %2d | %2d | ", t, b, p); 
          p = p+1;
          switch (i.f){
              case LIT:
                  t = t+1;
                  s[t] = i.a;
                  break;
              case OPR:
                  switch(i.a){
                      case 0:
                          t = b - 1;
                          p = s[t + 3];
                          b = s[t + 2];
                          break;
                      case 1:
                          s[t] = -s[t];
                          break;
                      case 2: 
                          t = t - 1;
                          s[t] = s[t] + s[t + 1];
                          break;
                      case 3:
                          t = t - 1;
                          s[t] = s[t] - s[t + 1];
                          break;
                      case 4: 
                          t = t - 1;
                          s[t] = s[t] * s[t + 1];
                          break;
                      case 5:
                          t = t - 1;
                          s[t] = s[t] / s[t + 1];
                          break;
                      case 6:
                          s[t] = (s[t]) % 2;
                          break;
                      case 8:
                          t = t - 1;
                          s[t] = (s[t] == s[t + 1]);
                          break;
                      case 9:
                          t = t - 1;
                          s[t] = (s[t] != s[t + 1]);
                          break;
                      case 10:
                          t = t - 1;
                          s[t] = (s[t] < s[t + 1]);
                          break;
                      case 11:
                          t = t - 1;
                          s[t] = (s[t] >= s[t + 1]);
                          break;
                      case 12: 
                          t = t - 1;
                          s[t] = (s[t] > s[t + 1]);
                          break;
                      case 13: 
                          t = t - 1;
                          s[t] = (s[t] <= s[t + 1]);
                          break;
                  }
                  break;
              case LOD:
                  t = t + 1;
                  s[t] = s[base(i.l) + i.a];
                  break;
              case STO:
                  s[base(i.l) + i.a] = s[t];
                  t = t - 1;
                  break;
              case CAL:
                  {
                    s[t + 1] = base(i.l);
                    s[t + 2] = b;
                    s[t + 3] = p;
                    b = t + 1;
                    p = i.a;
                  }
                  break;
              case INT:
                  t = t + i.a;
                  break;
              case JMP:
                  p = i.a;
                  break;
              case JPC:
                  if (s[t] == 0){
                      p = i.a;
                      t = t - 1;
                  }
                  break;
              case END:
                  p = 0;
                  break;
          }
          for(int j = 1; j <= t; j++){
              printf("[%d]", s[j]); 
          }
      } while(p != 0);
  }
  return 0;
}
